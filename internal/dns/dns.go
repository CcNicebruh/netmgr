package dns

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time" // Add the missing time import

	"github.com/RimakiTaema/netmgr/internal/common"
)

// HandleCommand processes DNS commands
func HandleCommand(command string, params []string) {
	switch command {
	case "show", "list":
		showDNS()
	case "set":
		if len(params) < 1 {
			common.LogError("Usage: dns set <primary_server> [secondary_server]")
			return
		}
		var secondary string
		if len(params) > 1 {
			secondary = params[1]
		}
		setDNS(params[0], secondary)
	case "help":
		showHelp()
	default:
		common.LogError("Unknown DNS command: %s", command)
	}
}

func showHelp() {
	fmt.Println(`DNS Configuration Commands:

    show                  Show current DNS configuration
    set <primary> [secondary]
                          Set DNS servers

Examples:
    netmgr dns show
    netmgr dns set 8.8.8.8 1.1.1.1`)
}

func showDNS() {
	common.LogInfo("DNS configuration:")
	fmt.Println()

	fmt.Printf("%s=== Current DNS Servers ===%s\n", common.ColorCyan, common.ColorReset)
	
	if common.IsLinux() {
		// Read resolv.conf
		data, err := os.ReadFile("/etc/resolv.conf")
		if err == nil {
			fmt.Println(string(data))
		} else {
			common.LogError("Failed to read resolv.conf: %v", err)
		}
	} else if common.IsWindows() {
		// Use PowerShell to get DNS servers
		output, err := common.Execute("powershell", "-Command", 
			"Get-DnsClientServerAddress -AddressFamily IPv4 | Select-Object -ExpandProperty ServerAddresses")
		if err == nil {
			fmt.Println(output)
		} else {
			common.LogError("Failed to get DNS servers: %v", err)
		}
	} else if common.IsMacOS() {
		// Use scutil to get DNS servers
		output, err := common.Execute("scutil", "--dns")
		if err == nil {
			fmt.Println(output)
		} else {
			common.LogError("Failed to get DNS servers: %v", err)
		}
	} else {
		common.LogError("Showing DNS configuration not implemented for this platform")
	}

	fmt.Printf("\n%s=== DNS Test ===%s\n", common.ColorCyan, common.ColorReset)
	
	// Test DNS resolution
	var cmd string
	var args []string
	
	if common.IsWindows() {
		cmd = "nslookup"
		args = []string{"google.com"}
	} else {
		cmd = "dig"
		args = []string{"google.com", "+short"}
	}
	
	output, err := common.Execute(cmd, args...)
	if err == nil {
		fmt.Println(output)
	} else {
		common.LogError("DNS test failed: %v", err)
	}
}

func setDNS(primary, secondary string) {
	common.LogInfo("Setting DNS servers: %s %s", primary, secondary)
	
	if common.IsLinux() {
		setLinuxDNS(primary, secondary)
	} else if common.IsWindows() {
		setWindowsDNS(primary, secondary)
	} else if common.IsMacOS() {
		setMacOSDNS(primary, secondary)
	} else {
		common.LogError("Setting DNS servers not implemented for this platform")
	}
}

func setLinuxDNS(primary, secondary string) {
	// Backup current resolv.conf
	backupFile := "/etc/resolv.conf.backup." + fmt.Sprint(time.Now().Unix())
	_, err := common.Execute("cp", "/etc/resolv.conf", backupFile)
	if err != nil {
		common.LogError("Failed to backup resolv.conf: %v", err)
	}
	
	// Create new resolv.conf content
	content := fmt.Sprintf("# Generated by netmgr on %s\n", time.Now().Format(time.RFC3339))
	content += fmt.Sprintf("nameserver %s\n", primary)
	if secondary != "" {
		content += fmt.Sprintf("nameserver %s\n", secondary)
	}
	
	// Write to temp file first
	tempFile := filepath.Join(os.TempDir(), "resolv.conf.new")
	err = ioutil.WriteFile(tempFile, []byte(content), 0644)
	if err != nil {
		common.LogError("Failed to create temporary resolv.conf: %v", err)
		return
	}
	
	// Move to /etc/resolv.conf
	_, err = common.Execute("mv", tempFile, "/etc/resolv.conf")
	if err != nil {
		common.LogError("Failed to update resolv.conf: %v", err)
		os.Remove(tempFile)
	}
}

func setWindowsDNS(primary, secondary string) {
	// Get network interfaces
	output, err := common.Execute("powershell", "-Command", 
		"Get-NetAdapter | Where-Object {$_.Status -eq 'Up'} | Select-Object -ExpandProperty Name")
	if err != nil {
		common.LogError("Failed to get network interfaces: %v", err)
		return
	}
	
	// Set DNS for each active interface
	interfaces := strings.Split(strings.TrimSpace(output), "\r\n")
	for _, iface := range interfaces {
		if secondary == "" {
			_, err = common.Execute("netsh", "interface", "ip", "set", "dns", 
				fmt.Sprintf("name=\"%s\"", iface), "static", primary)
		} else {
			_, err = common.Execute("netsh", "interface", "ip", "set", "dns", 
				fmt.Sprintf("name=\"%s\"", iface), "static", primary)
			if err == nil {
				_, err = common.Execute("netsh", "interface", "ip", "add", "dns", 
					fmt.Sprintf("name=\"%s\"", iface), secondary, "index=2")
			}
		}
		
		if err != nil {
			common.LogError("Failed to set DNS for interface %s: %v", iface, err)
		} else {
			common.LogInfo("Set DNS servers for interface %s", iface)
		}
	}
}

func setMacOSDNS(primary, secondary string) {
	// Get active network service
	output, err := common.Execute("networksetup", "-listallnetworkservices")
	if err != nil {
		common.LogError("Failed to list network services: %v", err)
		return
	}
	
	// Parse services (skip first line which is a header)
	services := strings.Split(strings.TrimSpace(output), "\n")[1:]
	
	for _, service := range services {
		// Check if service is active
		active, err := common.Execute("networksetup", "-getnetworkserviceenabled", service)
		if err != nil || !strings.Contains(strings.ToLower(active), "enabled") {
			continue
		}
		
		// Set DNS servers
		var dnsServers string
		if secondary == "" {
			dnsServers = primary
		} else {
			dnsServers = primary + " " + secondary
		}
		
		_, err = common.Execute("networksetup", "-setdnsservers", service, dnsServers)
		if err != nil {
			common.LogError("Failed to set DNS for service %s: %v", service, err)
		} else {
			common.LogInfo("Set DNS servers for service %s", service)
		}
	}
}
