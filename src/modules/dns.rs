use anyhow::Result;
use std::path::Path;
use tokio::fs;
use chrono::Utc;

use crate::cli::DnsCommands;
use crate::common::*;

pub async fn handle_command(command: DnsCommands, options: &GlobalOptions) -> Result<()> {
    match command {
        DnsCommands::Show => show_dns(options).await,
        DnsCommands::Set { primary, secondary } => {
            set_dns(&primary, secondary.as_deref(), options).await
        }
    }
}

async fn show_dns(options: &GlobalOptions) -> Result<()> {
    log_info("DNS configuration:");
    println!();
    
    println!("{}=== Current DNS Servers ==={}", COLORS.cyan, COLORS.reset);
    
    #[cfg(target_os = "linux")]
    {
        if let Ok(content) = fs::read_to_string("/etc/resolv.conf").await {
            println!("{}", content);
        } else {
            log_error("Failed to read /etc/resolv.conf");
        }
    }
    
    #[cfg(target_os = "windows")]
    {
        let output = execute_command("powershell", &["-Command", 
            "Get-DnsClientServerAddress -AddressFamily IPv4 | Select-Object -ExpandProperty ServerAddresses"], options).await?;
        println!("{}", output);
    }
    
    #[cfg(target_os = "macos")]
    {
        let output = execute_command("scutil", &["--dns"], options).await?;
        println!("{}", output);
    }
    
    println!("\n{}=== DNS Test ==={}", COLORS.cyan, COLORS.reset);
    
    // Test DNS resolution
    #[cfg(target_os = "windows")]
    {
        let output = execute_command("nslookup", &["google.com"], options).await?;
        println!("{}", output);
    }
    
    #[cfg(not(target_os = "windows"))]
    {
        let output = execute_command("dig", &["google.com", "+short"], options).await?;
        println!("{}", output);
    }
    
    Ok(())
}

async fn set_dns(primary: &str, secondary: Option<&str>, options: &GlobalOptions) -> Result<()> {
    log_info(&format!("Setting DNS servers: {} {}", primary, secondary.unwrap_or("")));
    
    #[cfg(target_os = "linux")]
    {
        set_linux_dns(primary, secondary, options).await?;
    }
    
    #[cfg(target_os = "windows")]
    {
        set_windows_dns(primary, secondary, options).await?;
    }
    
    #[cfg(target_os = "macos")]
    {
        set_macos_dns(primary, secondary, options).await?;
    }
    
    Ok(())
}

#[cfg(target_os = "linux")]
async fn set_linux_dns(primary: &str, secondary: Option<&str>, options: &GlobalOptions) -> Result<()> {
    // Backup current resolv.conf
    let backup_file = format!("/etc/resolv.conf.backup.{}", Utc::now().timestamp());
    execute_command("cp", &["/etc/resolv.conf", &backup_file], options).await?;
    
    // Create new resolv.conf content
    let mut content = format!("# Generated by netmgr on {}\n", Utc::now().format("%Y-%m-%d %H:%M:%S"));
    content.push_str(&format!("nameserver {}\n", primary));
    if let Some(sec) = secondary {
        content.push_str(&format!("nameserver {}\n", sec));
    }
    
    // Write to temp file first
    let temp_file = "/tmp/resolv.conf.new";
    fs::write(temp_file, content).await?;
    
    // Move to /etc/resolv.conf
    execute_command("mv", &[temp_file, "/etc/resolv.conf"], options).await?;
    
    Ok(())
}

#[cfg(target_os = "windows")]
async fn set_windows_dns(primary: &str, secondary: Option<&str>, options: &GlobalOptions) -> Result<()> {
    // Get network interfaces
    let output = execute_command("powershell", &["-Command", 
        "Get-NetAdapter | Where-Object {$_.Status -eq 'Up'} | Select-Object -ExpandProperty Name"], options).await?;
    
    // Set DNS for each active interface
    let interfaces: Vec<&str> = output.trim().split('\n').collect();
    for interface in interfaces {
        let interface = interface.trim();
        if !interface.is_empty() {
            execute_command("netsh", &["interface", "ip", "set", "dns", 
                                      &format!("name=\"{}\"", interface), "static", primary], options).await?;
            
            if let Some(sec) = secondary {
                execute_command("netsh", &["interface", "ip", "add", "dns", 
                                          &format!("name=\"{}\"", interface), sec, "index=2"], options).await?;
            }
            
            log_info(&format!("Set DNS servers for interface {}", interface));
        }
    }
    
    Ok(())
}

#[cfg(target_os = "macos")]
async fn set_macos_dns(primary: &str, secondary: Option<&str>, options: &GlobalOptions) -> Result<()> {
    // Get active network service
    let output = execute_command("networksetup", &["-listallnetworkservices"], options).await?;
    
    // Parse services (skip first line which is a header)
    let services: Vec<&str> = output.lines().skip(1).collect();
    
    for service in services {
        // Check if service is active
        let active_output = execute_command("networksetup", &["-getnetworkserviceenabled", service], options).await?;
        if !active_output.to_lowercase().contains("enabled") {
            continue;
        }
        
        // Set DNS servers
        let dns_servers = if let Some(sec) = secondary {
            format!("{} {}", primary, sec)
        } else {
            primary.to_string()
        };
        
        execute_command("networksetup", &["-setdnsservers", service, &dns_servers], options).await?;
        log_info(&format!("Set DNS servers for service {}", service));
    }
    
    Ok(())
}
